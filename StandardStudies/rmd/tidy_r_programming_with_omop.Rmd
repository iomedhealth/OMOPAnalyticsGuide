---
knit: |
  (function(inputFile, encoding) {
    rmarkdown::render(
      inputFile,
      encoding = encoding,
      output_format = rmarkdown::github_document(html_preview = FALSE),
      output_file = file.path('../../_includes/rmd_output', paste0(tools::file_path_sans_ext(basename(inputFile)), '.md'))
    )
  })
---

This RMD contains the code examples from the Tidyverse and OMOP CDM guide.

## Chapter 1: A first analysis using data in a database

```{r setup-knitr, include=FALSE}
# Set up knitr options for knitting the Rmd file.
# The upload.fun option modifies the image path for embedding in the final document.
knitr::opts_knit$set(upload.fun = function(x) sub("^\\.\\./\\.\\./", "/", x))
# The fig.path option sets the directory where plots generated by the R code chunks will be saved.
knitr::opts_chunk$set(fig.path = "../../assets/images/rmd_output/")
```

```{r load-libraries-general, message=FALSE, warning=FALSE}
# Load the libraries
library(dplyr)
library(dbplyr)
library(ggplot2)
library(DBI)
library(duckdb)
```

### Inserting Data into a Database

```{r insert-iris}
# Create an in-memory duckdb database
db <- dbConnect(drv = duckdb())

# Write the iris dataframe to a table named "iris" in the database
dbWriteTable(db, "iris", iris)

# You can see the tables in the database
dbListTables(db)
```

### From R to SQL: The Power of `dbplyr`

```{r dbplyr-example}
# Create a reference to the `iris` table in the database
iris_db <- tbl(db, "iris")

# Get a summary of sepal length by species
iris_db |>
  group_by(Species) |>
  summarise(
    n = n(),
    mean_sepal_length = mean(Sepal.Length, na.rm = TRUE)
  )
```

### Bringing Data into R for Visualization

```{r visualization}
iris_db |>
  select("Species", "Sepal.Length") |>
  collect() |> # This brings the data from the database into an R dataframe
  ggplot(aes(x = `Sepal.Length`, fill = Species)) +
  geom_histogram(binwidth = 0.2, colour = "black") +
  facet_wrap(~Species, ncol = 1) +
  theme_bw()
```

### Disconnecting from the Database

```{r disconnect}
dbDisconnect(db)
```

## Chapter 2: Core verbs for analytic pipelines utilising a database

```{r setup-chapter2}
# Create database
db <- dbConnect(duckdb())

# Split iris into two tables: species info and measurements
species_info <- iris |> select(Species) |> distinct() |> mutate(species_id = row_number())
measurements <- iris |> left_join(species_info, by = "Species")

# Write tables
dbWriteTable(db, "species_info", species_info)
dbWriteTable(db, "measurements", measurements)

# Create lazy references
species_db <- tbl(db, "species_info")
measurements_db <- tbl(db, "measurements")
```

### Selecting Rows: `filter()` and `distinct()`

```{r filter-distinct}
measurements_db |>
  filter(Sepal.Length > 5) |>
  select(Species, Sepal.Length)

measurements_db |>
  distinct(Species)
```

### Ordering Rows: `arrange()`

```{r arrange}
measurements_db |>
  arrange(desc(Sepal.Length)) |>
  select(Species, Sepal.Length)
```

### Column Transformation: `mutate()`, `select()`, `rename()`

```{r mutate-select-rename}
measurements_db |>
  mutate(
    sepal_ratio = Sepal.Length / Sepal.Width,
    is_large = Sepal.Length > 6
  ) |>
  select(Species, sepal_ratio, is_large)

measurements_db |>
  select(Species, Sepal.Length, Petal.Length)

measurements_db |>
  rename(sepal_length = Sepal.Length)
```

### Grouping and Aggregation: `group_by()`, `summarise()`, `count()`

```{r group-summarise-count}
measurements_db |>
  group_by(Species) |>
  summarise(
    avg_sepal = mean(Sepal.Length, na.rm = TRUE),
    count = n()
  )

measurements_db |>
  count(Species, sort = TRUE)
```

### Joining Tables

```{r joins}
measurements_db |>
  left_join(species_db, by = "Species") |>
  select(Species, Sepal.Length)
```

### Constructing a Tidy Analytic Dataset

```{r analytic-dataset}
analytic_dataset <- measurements_db |>
  group_by(Species) |>
  summarise(
    avg_sepal_length = mean(Sepal.Length, na.rm = TRUE),
    avg_petal_length = mean(Petal.Length, na.rm = TRUE),
    total_measurements = n()
  ) |>
  arrange(desc(avg_sepal_length))

# Collect for analysis
analytic_dataset |> collect()
```

## Chapter 3: Supported expressions for database queries

### Logical Comparisons and Operators

```{r logical-ops}
measurements_db |> filter(Sepal.Length > 5 & Petal.Length > 3)
```

### Conditional Statements

```{r conditional}
measurements_db |>
  mutate(
    size_category = case_when(
      Sepal.Length < 5 ~ "small",
      Sepal.Length <= 6 ~ "medium",
      TRUE ~ "large"
    )
  )
```

### String Functions

```{r string-funcs}
species_db |>
  mutate(
    species_upper = toupper(Species),
    species_length = nchar(Species),
    species_substr = substr(Species, 1, 3)
  )
```

## Chapter 4: Building analytic pipelines for a data model

### Example: Analyzing Iris Measurements

```{r pipeline-example}
# Step 1: Filter and prepare data
iris_performance <- measurements_db |>
  filter(!is.na(Sepal.Length), !is.na(Petal.Length))

# Step 2: Calculate metrics
performance_metrics <- iris_performance |>
  mutate(
    sepal_petal_ratio = Sepal.Length / Petal.Length,
    is_large_flower = as.numeric(Sepal.Length > 6)
  ) |>
  group_by(Species) |>
  summarise(
    total_flowers = n(),
    avg_sepal_petal_ratio = mean(sepal_petal_ratio, na.rm = TRUE),
    large_percentage = mean(is_large_flower, na.rm = TRUE) * 100
  )

# Step 3: Filter for significant groups
significant_species <- performance_metrics |>
  filter(total_flowers >= 40) |>
  arrange(desc(avg_sepal_petal_ratio))

# Collect results
results <- significant_species |> collect()
```

### Creating Reusable Functions

```{r reusable-functions}
calculate_ratios <- function(measurements_tbl) {
  measurements_tbl |>
    mutate(
      sepal_petal_ratio = Sepal.Length / Petal.Length,
      is_large = as.numeric(Sepal.Length > 6)
    ) |>
    summarise(
      total = n(),
      avg_ratio = mean(sepal_petal_ratio, na.rm = TRUE),
      large_pct = mean(is_large, na.rm = TRUE)
    )
}

# Use the function
species_ratios <- measurements_db |>
  group_by(Species) |>
  calculate_ratios()
```

